# 菠萝觅公共基础类库 (@boluome/common-lib)

```js
  import * as commonLib from '@boluome/common-lib'
```

安装（需登陆参与菠萝觅组织的账号）
```bash
  $ npm install @boluome/common-lib
```

按需引用
```js
  //按需引用
  import { add, parseQuery, moment, send } from '@boluome/common-lib'
```

Moment模块:
```js
  import { moment, addDay, addHour, addMinute, addSecond, compose, week, duration } from '@boluome/common-lib'

  //格式化日期
  const d = new Date() // => 2017-02-15
  moment('YYYY/MM/DD')(d) // => 2017/02/15

  //格式化时间戳
  const ts = 1487136727315
  moment('YYYY-MM-DD HH:mm:ss')(ts) // => 2017-02-15 13:32:07

  //格式化成时间戳
  moment('x')(d) // => 1487136727315

  //历时 [天，时，分] 默认为 0
  const st = '2017-02-14 12:00'
  const et = '2017-02-16 13:09'
  duration(moment('x')(st), moment('x')(et)) //返回 [ 2, 1, 9 ]

  //格式化星期，默认：周*
  week()(moment('day')(d)) // => 周三
  //组合做法
  compose(week(), moment('day'))(d)
  //星期* 形式
  const weekArr = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六']
  compose(week(weekArr), moment('day'))(d) // => 星期三
  //英文  形式
  const engArr  = ['Sun.', 'Mon.', 'Tue.', 'Wed.', 'Thu.', 'Fri.', 'Sat.']
  compose(week(engArr), moment('day'))(d) // => Wed.


  /*
      在日期上添加 n 天(时、分、秒)
      addDay(step, d) / addHour(step, d) / addMinute(step, d) / addSecond(step, d)
      step: 添加 n 天(时、分、秒)
      d   : Date | DateStr | TimeStamp
  */
  //例:
  moment('YYYY-MM-DD')(addDay(1)(moment('x')(d))) // => 2016-02-16
  //或
  compose(moment('YYYY-MM-DD'), addDay(1), moment('x'))(d) // => 2016-02-16

  //扩展使用场景
  const startDate = '2017/02/15'
  const endDate   = '2017/02/15'
  const toTs      = moment('x')

  const postData = {
    sts: toTs(startDate),
    ets: toTs(endDate),   
    ...
  }

  fetch('/order', postData).then(...)
```

Url模块:
```js
  import { stringifyQuery, parseQuery, setServerUrl, api } from '@boluome/common-lib'

  //设置serverUrl，统一请求出口路径，需分环境配置
  setServerUrl('http://api.otosaas.com')

  //判断api类型，如果是path会默认加上serverUrl，如果是有效URL则返回有效URL
  api('/handler') // http://api.otosaas.com/handler
  api('http://api.other.com/handler2') //http://api.other.com/handler2

  //将 url search 转成对象
  const search = location.search //?a=1&b=2
  parseQuery(search) // => { a: 1, b: 2 }

  //将对象转成 url search
  const params = { a: 1, b: 2 }
  stringifyQuery(params) // => ?a=1&b=2
```

Ajax模块:
```js
  import { get, send } from '@boluome/common-lib'

  //Get方式
  get('/handler') // get -> http://xxx.com/handler
  get('/handler', { a: 1, b: 2 })  // get -> http://xxx.com/handler?a=1&b=2

  //Send(url, data[, method][, headers])
  send('/handler', { a: 1, b: 2 })
  send('/handler', { a: 1, b: 2 }, 'DELETE')
  send('/handler', { a: 1, b: 2 }, 'PUT', { Content-Type: 'xxx' })
  send('/handler', { a: 1, b: 2 }, { Content-Type: 'xxx' })

  //返回处理
  get('/handler')
  .then(reply => {
    const { code, data, message } = reply
    console.log(...)
  })
  .catch(err => console.log(err))

```

Storage模块:
```js
  import { setStore, getStore, removeStore } from '@boluome/common-lib'

  //设置localStorage
  setStore('string', 'localStorage')
  setStore('object', { type: 'localStorage' })

  //设置sessionStorage
  setStore('string', 'sessionStorage', 'session')
  setStore('object', { type: 'sessionStorage' }, 'session')

  //获取localStorage
  getStore('string')  // -> localStorage
  getStore('object')  // -> { type: 'localStorage' }

  //获取sessionStorage
  getStore('string', 'session')  // -> sessionStorage
  getStore('object', 'session')  // -> { type: 'sessionStorage' }

  //删除localStorage
  removeStore('string')
  //删除sessionStorage
  removeStore('string', 'session')

```

---
基于 [Ramda](http://ramdajs.com/) 。它提供了一系列的功能函数，参考 [Ramda API](http://ramdajs.com/docs)，例：

```js
  import { add, multiply, sum, curry, compose } from 'ramda'

  add(1, 2) // => 3

  //compose 组合
  compose(multiply(2), add(1), add(1))(2) // => 8 注：(2 + 1 + 1) * 2

  //curry   柯里化
  const f = (a, b, c) => sum([a, b, c])

  f(1, 2, 3) // => 6

  const f2 = curry(f)

  f2(1)(2)(3) // => 6

  //Ramda提供的函数都是curry后的，实际应用场景
  const addTen = add(10)
  const addOne = add(1)

  addTen(1) // => 11
  addOne(1) // => 2
```

函数式编程的理念可以看一下： [mostly-adequate-guide-chinese](https://github.com/llh911001/mostly-adequate-guide-chinese)
